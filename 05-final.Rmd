---
title: "05final_summary"
author: "Max"
date: "2024-04-29"
output: html_document
---

```{r}
library(readr)
library(dplyr)
library(tidyr)
library(tidyverse)

```



```{r}
#Clean data code (data defined as latest_filtered)
#Taking out na values and only using 2021
cities <- read_csv("data/bigcities_wide.csv")
us_total = cities %>% filter(geo_label_city == "U.S. Total")

## Work with 2021 or 2020 data
new_cities = cities %>% filter(date_label == 2021)
na_count = colSums(is.na(new_cities)) / nrow(new_cities)
lowna = na_count[colSums(is.na(new_cities)) / nrow(new_cities) < .33]
lowna_cols = names(lowna)
cities_nona = new_cities %>% select(all_of(lowna_cols))
## Impute as dataframe
cities_clean <- cities_nona %>%
  mutate(across(where(is.numeric), ~ifelse(is.na(.), median(., na.rm = TRUE), .))) %>% 
  filter(geo_label_city != "U.S. Total")

numeric_data <- cities_clean %>% filter(geo_label_city != "U.S. Total") %>% select(!c("geo_label_city", "geo_fips_code", "date_label")) # Exclude the first column containing city names
rownames(numeric_data) = cities_clean$geo_label_city  # Transpose the numeric data

```

## Exploratory Data Analysis

Our goal is to see what we can predict given the quality of a city. To start, we will build a model attempting to give a "rating" of a city, comparing this to another source's list on what are the best cities. 

The first step is going to be choosing suitable variables.

The initial data analysis gave us about 

```{r}
#colnames(num_cols) # These are the variables
## label columns are geo_label_city, geo_fips_code
## Numerical columns
num_cols = cities_clean %>% select(!c(geo_label_city, geo_fips_code, date_label))## 88 columns
par(mfrow=c(3,3), mar=c(4,4,2,0.5))
# Iterate over numeric columns and plot histograms
for (j in seq_along(num_cols)) {
  hist(num_cols[[j]], 
       xlab=names(num_cols)[j],
       main=paste("Histogram of", names(num_cols)[j]),
       col="lightblue", breaks=20)
}
```

The initial histogram shows a decent amount of variation in the variables. Because we have high dimension (p) and low sample size, this can lead to a lot of problems with dimensionality. To fix this, we are going to try to reduce multicollinearity by using correlation and domain understanding.

Before this, we are going to do some initial clustering to see if there are any groupings that we could potentially use to reduce dimensions.


There are a lot of variables, most seem to be fairly normal, although there does seem to be some categories that have similar distributions. Deaths, drug related variables, transporation variables, all seem to be pretty similar within its own group.

## Second Method: Dimension Reduction through feature selection by domain knowledge

```{r}
## 80 is too much to look at overall, but for some EDA going to look at first 10
cor(num_cols[,1:10]) # Very high correlation, need to see further how bad this problem is
library(corrr)
cor_matrix = cor(num_cols, use = "na.or.complete")
cor_matrix[,1]
cor_melted <- as.data.frame(as.table(cor_matrix))

# Filter to remove self-correlations and get only one of each pair
cor_melted_filtered <- subset(cor_melted, Var1 != Var2 & as.numeric(Var1) < as.numeric(Var2))

# Filter for high correlations
high_cor_pairs <- subset(cor_melted_filtered, abs(Freq) > 0.75)
print(high_cor_pairs)
```
There are 400 pairs of very high correlation (>.75). Sources of this are:
  - Death Variables
  - Children related variables
  - Transportation Variables
  - Single Parent Families
  - Income Inequality related variables
  - Poverty related variables

Specific variables that have a lot of high correlation are:
  - Preterm Births
  - Premature Death
  - Life Expectancy
  - Single-Parent Families
  - Household Income Inequality
  - Service Workers
  

With this level of correlation, using this to classify something, even like total score will not yield much meaningful results. However, we will try to classify cities into categories/groupings, and attempt to explain the variation when it does vary from each other, and apply these groupings in other situations.

In this part we will attempt to reduce our 86 variables to between 10-20 variables, and then try hierarchical clustering on these variables to attempt to get groupings. We will do this through a mix of checking correlations and domain understanding. THis will not be super mathematically driven, as we can look from the original histograms and these correlation matrices that there is no major difference between most of these variables, so we will pick variables that we think will give us the greatest amount of interpretability while still being able to keep some level of predictive power.

```{r}
colnames(cities_clean %>% select(!c("geo_label_city", "geo_fips_code", "date_label")))
```
A solid percentage of variables have to do with death/life expectancy. We are going to try to reduce these into a few variables, as many of these have very high correlations as well. These are a list of a bunch of variables that are all related to life expectancies and death.

```{r}
health_vars = c("COVID-19 Deaths","Deaths from All Causes", "Life Expectancy", "All Cancer Deaths", "Breast Cancer Deaths", "Lung Cancer Deaths", "Cardiovascular Disease Deaths", "Heart Disease Deaths", "High Blood Pressure",  "Diabetes", "Adult Obesity", "Adult Physical Inactivity", "Pneumonia or Influenza Deaths", "HIV-Related Deaths", "HIV/AIDS Prevalence", "New Chlamydia Cases", "Syphilis Prevalence", "Syphilis, Newborns", "New Gonorrhea Cases", "Maternal Deaths", "Infant Deaths", "Low Birthweight","Teen Births", "Opioid Overdose Deaths", "Adult Binge Drinking", "Drug Overdose Deaths", "Adult Smoking", "Injury Deaths", "Gun Deaths (Firearms)","Motor Vehicle Deaths",  "Police Killings", "Violent Crime", "Homicides", "Seniors", "Colorectal Cancer Deaths", "Prostate Cancer Deaths",         "Preterm Births","Premature Death"  )
```

```{r}
death_cor = corrr::correlate(cities_clean %>% select(contains("death")))
death_cor
```
*Premature Deaths* is a variable that can capture the pattern we are looking for, which is various stats that show taht people are unhealthier or dying earlier. This may allow us to reduce the features that we look through. Looking at the correlations for premature deaths, we can see very high correlation between the cancer variables and a bunch of other of the death variables. We are choosing to keep this, and will see what other death variables we will keep.

```{r}
prem_cor = death_cor[21]
hi_var_prem = death_cor$term[(prem_cor %>% pull("Premature Death")) > .75]
drop_vars = c()
drop_vars = append(drop_vars,hi_var_prem) # Drop NA values
## Checking other correlations with premature deaths
death_cor2 = corrr::correlate(cities_clean %>% select(c("Premature Death",  "Life Expectancy","High Blood Pressure",  "Diabetes", "Adult Obesity", "Adult Physical Inactivity", "HIV-Related Deaths", "HIV/AIDS Prevalence", "New Chlamydia Cases", "Syphilis Prevalence", "Syphilis, Newborns", "New Gonorrhea Cases", "Low Birthweight","Teen Births", "Adult Binge Drinking", "Adult Smoking", "Police Killings", "Violent Crime", "Homicides", "Seniors", "Preterm Births")))
prem_cor2 = death_cor2[2]
hi_var_prem2 = death_cor2$term[abs(prem_cor2 %>% pull("Premature Death")) > .75]
drop_vars = append(drop_vars, hi_var_prem2)
drop_vars = drop_vars[!sapply(drop_vars, is.na)]
leftover = health_vars %>% setdiff(drop_vars)
## Checking correlation of leftover variables
corrr::correlate(cities_clean %>% select(all_of(leftover)))
## Other High Correlations: STD variables, Drug overdose
## Solving STD correlation problems: Combining into one variable
std_vars = c("HIV-Related Deaths", "HIV/AIDS Prevalence","New Chlamydia Cases", "Syphilis Prevalence", "Syphilis, Newborns","New Gonorrhea Cases")
std_df <- cities_clean %>%
  mutate(across(all_of(std_vars), 
                ~(. - mean(., na.rm = TRUE)) / sd(., na.rm = TRUE), 
                .names = "{.col}_standardized")) %>% 
  rowwise() %>%
  mutate(average_std = mean(c_across(ends_with("_standardized")), na.rm = TRUE)) %>%
  ungroup()
new_df = cities_clean
new_df$average_std = std_df$average_std
drop_vars = append(drop_vars, std_vars)
```
With some of the variables, there was obvious choices to be made, such as there was a .98 correlation between *Drug Overdose Deaths* and *Opioid Overdose Deaths*. We chose the drug variable as it was a little broader. However, with the std variables, there was no obvious variable that would be able to reflect the rest, so we combined them together into one variable that was an average of all of them. 

At this moment, *Premature Deaths* remains our choice of how to reflect the health/death related variales, as it is a good reflection based on an understanding of premature deaths as a concept. If a lot of people are dying earlier than expected it is likely an area with poor health, and potentially also dangerous. Although we may be losing a level of predictive power, it is necessary for us to be able to reduce the dimensionality of our problem.


Next, we will look at smaller relationships, starting with Homelessness, Transportation and segregation

```{r}
correlate(new_df %>% select(contains("Homelessness"))) # these can be kept the way they are
correlate(new_df %>% select(contains("Segregation"))) # Will focus primarily on White and Non-White, others wont be quite as important
correlate(new_df %>% select(contains("Poverty"))) ## Going to keep Poverty in all Ages
drop_vars = append(drop_vars, c("Opioid Overdose Deaths", "Racial Segregation, White and Black", "Racial Segregation, White and Asian", "Racial Segregation, White and Hispanic", "Poverty and Near Poverty in All Ages", "Poverty in Children"))
new_df = new_df %>% select(!any_of(drop_vars))
```

In this code chunk, we dropped the other segregation variables and are focusing on white and non-white, and kept the broader of the poverty variables: *Poverty in All Ages*.

We will be testing how many high correlation pairs we have left to see how many more variables we need to drop.

## Checking how much correlation we have left
```{r}
cor_matrix = cor(new_df %>% select(!c("geo_label_city", "geo_fips_code", "date_label")), use = "na.or.complete")
cor_matrix[,1]
cor_melted <- as.data.frame(as.table(cor_matrix))

# Filter to remove self-correlations and get only one of each pair
cor_melted_filtered <- subset(cor_melted, Var1 != Var2 & as.numeric(Var1) < as.numeric(Var2))

# Filter for high correlations
high_cor_pairs <- subset(cor_melted_filtered, abs(Freq) > 0.75)
print(high_cor_pairs)
high_cor_pairs %>% group_by(Var1) %>% count() %>% arrange(desc(n))
high_cor_pairs %>% group_by(Var2) %>% count() %>% arrange(desc(n))
```
Variables with high correlations with other variables are as we printed out. We wish to capture some factor about economy, some factor of health, some factor about housing, something with education, and something with transportation. 

From here we are going to drop variables that have high correlations and do not seem to be helpful. To begin, *Lack of Car* has high correlations with 2 variables, and lack of car seems like it could be explained easily by other variables such as income and city, and this can be covered by the walking to work variable. The *Service Workers* variable is another variable that has high correlations, and this variation could be covered by other variables such as income, and does not seem to be too important to predict city type. The income related variables all seem to have a lot of correlated relationships. *Household Income Inequality* is highly correlated with many other variables, and so we will drop all the variables that it has high correlation with to see if we can explan the variation related with other employment and income related variables.

*Population Density* is a variable that is highly correlated with many variables, and when it comes to quality of a city, density is not the only factor, and the related factors could be more powerful and capture this variation such as transportation and supermarket access among others.

Smaller Pairs that have high variation: 
- Uninsured, All Ages	vs. Uninsured, Child (keep *Uninsured, All Ages	*)
- Owner Occupied Housing vs. 	Renters vs. Owners (keep *Owner Occupied Housing*)
- Income Variables: keeping *Per-capita Household Income*
- *Drives Alone to Work*: Other important variables similar to this

```{r}
## Employee/Income variables
emp_inc_vars = c("Poverty in All Ages", "Per-capita Household Income", "Households with Higher-Incomes", "Service Workers", "Unemployment")
## Transportation Variables
transp_vars = c("Drives Alone to Work", "Population Density", "Riding Bike to Work", "Longer Driving Commute Time", "Walking to Work", "Lack of Car", "Public Transportation Use")
correlate(new_df %>% select(any_of(emp_inc_vars)))
correlate(new_df %>% select(any_of(transp_vars)))
more_vars = setdiff(emp_inc_vars, "Poverty in All Ages") %>%
  union(
  setdiff(transp_vars, "Public Transportation Use")
)
new_df = new_df %>% select(!any_of(more_vars)) %>% select(!`Uninsured, Child`)
```
Looking through transportation related variables and employment/income variables, we are going to keep *Public Transportation Use* and *Poverty in all Ages*, because these were both highly correlated with the other variables within their category, and are very explainable for reasons, as poverty and public transportation seem to be very important for a city and its quality of living.


```{r}
cor_matrix = cor(new_df %>% select(!c("geo_label_city", "geo_fips_code", "date_label")), use = "na.or.complete")
cor_matrix[,1]
cor_melted <- as.data.frame(as.table(cor_matrix))

# Filter to remove self-correlations and get only one of each pair
cor_melted_filtered <- subset(cor_melted, Var1 != Var2 & as.numeric(Var1) < as.numeric(Var2))

# Filter for high correlations
high_cor_pairs <- subset(cor_melted_filtered, abs(Freq) > 0.75)
print(high_cor_pairs)
high_cor_pairs %>% group_by(Var1) %>% count() %>% arrange(desc(n))
high_cor_pairs %>% group_by(Var2) %>% count() %>% arrange(desc(n))
```
Last variables droppped:

We have left a lot of important variables that all seem to potentially important. We need to drop a few of these variables, so there is no perfect solution. These are what we finally dropped:
- *People with Disabilities*: Seems like it could be represented by a number of other variables
- *Vacant Housing Units*: Does not seem as important, high correlation with other variables
- *Household Income Inequality*: very high correlation with poverty, also has high correlation with other variables
- *Single-Parent Families*: This would also seem to be highly correlated with poverty
- *Preschool Enrollment*: High correlation with college graduates which we like better
- *Owner Occupied Housing*: Almost 1 correlation with *Renters vs. Owners*, which we are keeping
- *Children*: Does not seem to predictive, there are better variables than this
- *Primarily Speak Spanish*, *Primarily Speak English*: *Foreign Born Population* is highly correlated and seems like it could be more important
- *Public Assistance*: This is highly correlated with poverty but we will be keeping the poverty variable
- *Dental Care*: Has high correlations but does not seem to be as predictive as many of the other variables in this for livability
- *New Tuberculosis Cases*: Not predictive
- *Adult Physical Inactivity*: high correlation with others and not as predictive


```{r}
final_drop = c(
  "People with Disabilities", "Vacant Housing Units", 
  "Household Income Inequality", "Single-Parent Families",
  "Preschool Enrollment", "Owner Occupied Housing", "Children",
  "Primarily Speak Spanish", "Dental Care", "Primarily Speak English", "Public Assistance", "New Tuberculosis Cases", "Adult Physical Inactivity"
)
new_df = new_df %>% select(!any_of(final_drop))
```
## Final Correlations
```{r}
cor_matrix = cor(new_df %>% select(!c("geo_label_city", "geo_fips_code", "date_label")), use = "na.or.complete")
cor_matrix[,1]
cor_melted <- as.data.frame(as.table(cor_matrix))

# Filter to remove self-correlations and get only one of each pair
cor_melted_filtered <- subset(cor_melted, Var1 != Var2 & as.numeric(Var1) < as.numeric(Var2))

# Filter for high correlations
high_cor_pairs <- subset(cor_melted_filtered, abs(Freq) > 0.75)
print(high_cor_pairs)
high_cor_pairs %>% group_by(Var1) %>% count() %>% arrange(desc(n))
high_cor_pairs %>% group_by(Var2) %>% count() %>% arrange(desc(n))
```
We are okay with a little bit of correlation, as long as it is not the majority of the dataset. We went from 400 pairs to only 6, and none of them are over .85, and if this is is still a problem we can reduce further. These are our variables with low correlations before some final domain understanding to further reduce to only important variables.

- Prostate, Diabetes, Flu/Pneumonia deaths: Not a huge portion of deaths are in this way, does not seem too important
- Homelessness and Vacant Housing: broad, covered by other homeless variabels

```{r}
colnames(new_df)
unimp_vars = c("Prostate Cancer Deaths", "Poor Air Quality","Primarily Speak Chinese",  "Prostate Cancer Deaths", "Diabetes Deaths", "Pneumonia or Influenza Deaths", "Homelessness and Vacant Housing" )
new_df = new_df %>% select(!all_of(unimp_vars))
```

## Final Variables for clustering
```{r}
colnames(new_df)
```

## base df on cities
```{r}
scaled_red = scale(new_df %>% select(!c(geo_label_city, geo_fips_code, date_label)))
hc_red = hclust(dist(scaled_red))
#hc = cutree(a, k = 5)
cluster_redassignments <- cutree(hc_red, k = 3)

# Create a dataframe with cluster assignments
df_redclusters <- data.frame(new_df, Cluster = as.factor(cluster_redassignments))
df_redclusters %>% select(geo_label_city, Cluster)
```

```{r}
plot(hc_red, labels = FALSE) # Set labels=FALSE to avoid cluttering
rect.hclust(hc_red, k = 3, border = "red") # Add rectangles to delineate the 4 clusters

rownames(new_df) = substr(new_df$geo_label_city, 1, 5)
# Add text labels
# Compute appropriate y positions for text labels (may need adjustment)
y_positions <- rep(min(hc_red$height), length(cluster_assignments))
text(x = 1:length(cluster_assignments), y = y_positions, labels = row.names(new_df), cex = 0.6, pos = 3)
```


## Hierarchical clustering on columns
```{r}
df_tred <- t(scaled_red)

# Calculate the distance matrix using Euclidean distance (you can choose another method)
dist_red_matrix <- dist(df_tred, method = "euclidean")

# Perform hierarchical clustering
hc_redcolumns <- hclust(dist_red_matrix, method = "complete") # You can choose another linkage method

# Plot the dendrogram
plot(hc_redcolumns, main = "Dendrogram of Columns", xlab = "Columns", sub = "", ylab = "Height")

varclusters_red <- cutree(hc_redcolumns, k = 5)

# If you want to see which columns are in each cluster

df_redvarclusters <- data.frame(df_tred, Cluster = as.factor(varclusters_red)) %>% select(Cluster)
```
## Final Variable Clusters:
Comparison between:
1) Clusters on Cities
```{r}
pca_clusters$Cities = rownames(pca_clusters)
df_clusters_joined = pca_clusters %>% left_join(
  df_redclusters %>% select(geo_label_city, Cluster), by = join_by("Cities" == "geo_label_city")
)
df_clusters_joined %>% select(Cities, starts_with("Clust"))
df = df_clusters_joined %>% mutate(
  hc_named = case_when(
    df_clusters_joined$Cluster.x == 1 ~ "low",
    df_clusters_joined$Cluster.x == 2 ~ "med",
    df_clusters_joined$Cluster.x == 3 ~ "hi",
    .default = NA
  )
)
```
With dimension reduction and PCA, the cluster categories were exactly the same. This is good for us keeping what we wanted.


```{r}
#library(dplyr)
library(igraph)
library(networkD3)
#View(df_varclusters)
#View(df_redvarclusters)
#df_sank = df_clusters_joined %>% select(Cluster.x, Cluster.y, Cities)
#write.csv(df_sank, "test.csv")
#plot_sankey(df_sank, from_to= c("Cities", "Cluster.x", "Cluster.y"))
```
Variable clusters vary greatly between the two.

# initial indexing of column names

```{r}
columnnames = colnames(cities_clean %>% select(!c(geo_label_city, geo_fips_code, date_label)))
columnnames
df_ctgy_health = list(
  tibble(ctgy = "health", sub_ctgy = "deaths", 
         col = columnnames[str_detect(columnnames, "Death|Suicide") & !str_detect(columnnames, "HIV|Diabetes") ]),
  tibble(ctgy = "health", sub_ctgy = "births", 
         col = columnnames[str_detect(columnnames, "Birth")]),
  tibble(ctgy = "health", sub_ctgy = "vaccinations", 
         col = columnnames[str_detect(columnnames, "Vaccination")]),
  tibble(ctgy = "health", sub_ctgy = "medicalcare", 
         col = columnnames[str_detect(columnnames, "Care|Uninsured")]),
  tibble(ctgy = "health", sub_ctgy = "stds", 
         col = columnnames[str_detect(columnnames, "HIV|Syphilis|Chlamydia|Gonorrhea")]),
  tibble(ctgy = "health", sub_ctgy = "conditions/disease", 
         col = columnnames[str_detect(columnnames, "Disabilities|Diab|Blood|Tuber|Obesity|Mental")]),
    tibble(ctgy = "health", sub_ctgy = "other_health", 
         col = columnnames[str_detect(columnnames, "Inactivity|Smok|Drink|Expect")])
) %>% bind_rows()
leftover = columnnames %>% setdiff(df_ctgy_health %>% pull(col))
df_ctgy_income = list(
  tibble(ctgy = "Income", sub_ctgy = "poverty", 
         col = leftover[str_detect(leftover, "Poverty|Unempl|Service")]),
  tibble(ctgy = "Income", sub_ctgy = "inc_level", 
         col = leftover[str_detect(leftover, "Inequ|Per-cap|Higher-Inc")])
  ) %>% bind_rows()
leftover = leftover %>% setdiff(df_ctgy_income %>% pull(col))
df_ctgy_transp =  list(
  tibble(ctgy = "transportation", sub_ctgy = "public", 
         col = leftover[str_detect(leftover, "Bike|Walk|Public")]),
    tibble(ctgy = "transportation", sub_ctgy = "drive", 
         col = leftover[str_detect(leftover, "Car|Driv")])
  
  ) %>% bind_rows()
leftover = leftover %>% setdiff(df_ctgy_transp %>% pull(col))
df_ctgy_hous = list(
  tibble(ctgy = "housing", sub_ctgy = "quality", 
         col = leftover[str_detect(leftover, "Lead")]),
    tibble(ctgy = "housing", sub_ctgy = "ownership", 
         col = leftover[str_detect(leftover, "Units|Owner")]),
  tibble(ctgy = "housing", sub_ctgy = "homeless", 
         col = leftover[str_detect(leftover, "Homelessness")]),
  tibble(ctgy = "housing", sub_ctgy = "cost", 
         col = leftover[str_detect(leftover, "Cost")])
  ) %>% bind_rows()
leftover = leftover %>% setdiff(df_ctgy_hous %>% pull(col))
df_ctgy_demog_life  = list(
  tibble(ctgy = "demography", sub_ctgy = "low-inc", 
         col = leftover[str_detect(leftover, "Children|Single-Parent|inority|Foreign|Spanish")]),
    tibble(ctgy = "demography", sub_ctgy = "hi-inc", 
         col = leftover[str_detect(leftover, "Grad|Seniors|Chinese|English")]),
  tibble(ctgy = "demography", sub_ctgy = "segreg", 
         col = leftover[str_detect(leftover, "Segregation")]),
    tibble(ctgy = "demography", sub_ctgy = "safety", 
         col = leftover[str_detect(leftover, "Air Quality|Violent|Killings|Homicides")]),
    tibble(ctgy = "demography", sub_ctgy = "other", 
         col = leftover[str_detect(leftover, "Preschool|Supermarket|Density")])
  ) %>% bind_rows()
leftover = leftover %>% setdiff(df_ctgy_demog_life %>% pull(col))
leftover
```
```{r}
df_cat = df_ctgy_health %>% 
  rbind(df_ctgy_demog_life) %>% 
  rbind(df_ctgy_hous) %>% 
  rbind(df_ctgy_income) %>% 
  rbind(df_ctgy_transp)
```


## Hierarchical clustering on columns
```{r}
scaled = scale(cities_clean %>% select(!c(geo_label_city, geo_fips_code, date_label)))
df_t <- t(scaled)

# Calculate the distance matrix using Euclidean distance (you can choose another method)
dist_matrix <- dist(df_t, method = "euclidean")

# Perform hierarchical clustering
hc_columns <- hclust(dist_matrix, method = "complete") # You can choose another linkage method

# Plot the dendrogram
plot(hc_columns, main = "Dendrogram of Columns", xlab = "Columns", sub = "", ylab = "Height")
```
#### Checking optimal clusters for variables
```{r}
sil_width <- vector("numeric", length = 14) # Adjust the length for the number of clusters to inspect minus one
for (k in 2:15) { # Starts from 2 because silhouette doesn't work with a single cluster
  cluster_assignments <- cutree(hc_columns, k)
  silhouette_analysis <- silhouette(cluster_assignments, dist_matrix)
  sil_width[k-1] <- mean(silhouette_analysis[, 3]) # Average silhouette width
}

# Plot the average silhouette width
plot(2:15, sil_width, type = "b", xlab = "Number of Clusters", ylab = "Average Silhouette Width", main = "Silhouette Method for Optimal Clusters")
```

```{r}
varclusters <- cutree(hc_columns, k = 6)

# If you want to see which columns are in each cluster

df_varclusters <- data.frame(df_t, Cluster = as.factor(varclusters)) %>% select(Cluster)
#dend <- as.dendrogram(hc_columns) # Visualizing dendrogram with actual column names
#labels(dend) <- rownames(numeric_data) # Adding names as labels
#plot(hc_columns, main = "Dendrogram of Columns", xlab = "Columns", sub = "", ylab = "Height")
df_varclusters$variables = rownames(df_varclusters)
```


# Hierarchical clustering on columns
```{r}
df_tred <- t(scaled_red)

# Calculate the distance matrix using Euclidean distance (you can choose another method)
dist_red_matrix <- dist(df_tred, method = "euclidean")

# Perform hierarchical clustering
hc_redcolumns <- hclust(dist_red_matrix, method = "complete") # You can choose another linkage method

# Plot the dendrogram
plot(hc_redcolumns, main = "Dendrogram of Columns", xlab = "Columns", sub = "", ylab = "Height")

varclusters_red <- cutree(hc_redcolumns, k = 3)

# If you want to see which columns are in each cluster

df_redvarclusters <- data.frame(df_tred, Cluster = as.factor(varclusters_red)) %>% select(Cluster)
df_redvarclusters$variables = rownames(df_redvarclusters)
```

```{r}
varclusters_joined = df_redvarclusters %>% left_join(
  df_varclusters, by = join_by("variables")
)
# for (i in 1:3){
# print(plot_sankey(varclusters_joined %>% filter(Cluster.x == i), from_to = c("Cluster.x", "clusters", "Cluster.y")))
# }
```


```{r}
df_display = df_varclusters %>% mutate(col = rownames(df_varclusters)) %>% left_join(df_cat, by = "col")
df_reddisplay = df_redvarclusters %>% mutate(col = rownames(df_redvarclusters)) %>% left_join(df_cat, by = "col")

#View(df_redvarclusters)
#View(df_varclusters)

# for (i in 1:6){
# print(plot_sankey(df_display %>% filter(Cluster == i), from_to = c("col", "ctgy", "Cluster", "sub_ctgy")))
# }
```

```{r}
# for (i in 1:3){
# print(plot_sankey(df_reddisplay %>% filter(Cluster == i), from_to = c("col", "ctgy", "Cluster", "sub_ctgy")))
# }
```



```{r}
library(igraph)
library(networkD3)
plot_sankey <- function(df, from_to, count_fn = "n", fn_col = NULL, ...)
{
  count_fn <- match.arg(count_fn, c("n", "n_distinct", "sum"), several.ok = FALSE)
  from_to_ls <- lapply(1:(length(from_to)-1L), function(x) {
    setNames(from_to[x:(x+1L)], c("from", "to"))
  })
  the_dots <- list(...)
  dat_ls <- lapply(from_to_ls, function(x){
    dat <- df %>%  dplyr::mutate(dplyr::across(dplyr::all_of(unname(x)),
                  function(y){
                    paste(dplyr::cur_column(), y, sep = ": ")
                  })) %>% dplyr::rename(dplyr::all_of(x)) %>% dplyr::group_by(from, to)
  if (count_fn == "n"){
    dat <- dat %>% summarise(n = n(), .groups = "drop")
  }
  else {
    dat <- dat %>% dplyr::summarise(dplyr::across(dplyr::all_of(fn_col),
                                                  function(y) {
                                                    do.call(count_fn, append(list(y), the_dots))
                                                  }, .names = "n"), .groups = "drop")}
    dat})
    dat_ls <- dat_ls[sapply(dat_ls, inherits, "data.frame")]
    dat <- do.call(rbind, dat_ls)
    graph_from_df <- igraph::graph_from_data_frame(dat)
    g_d3 <- networkD3::igraph_to_networkD3(graph_from_df)
    networkD3::sankeyNetwork(Links = g_d3$links, Nodes = g_d3$nodes, Source = "source", Target = "target", Value = "value", NodeID = "name", fontSize = 11, margin = c(top = 100, bottom= 100), sinksRight = FALSE)
}
```

```{r}
plot_sankey(df_cat, from_to = c("ctgy", "sub_ctgy", "col"))
```

## Build Scoring System
```{r}
## Cluster name
df_display = df_display %>%  mutate(Cluster = case_when(
    Cluster == 1 ~ "health_poverty_index",
    Cluster == 2 ~ "income_eq_educ_index",
    Cluster == 3 ~ "safety_index",
    Cluster == 4 ~ "suburb_sprawl_index",
    Cluster == 5 ~ "bigcity_segregat_index",
    Cluster == 6 ~ "std_drug_index",
    TRUE ~ as.character(Cluster)  # Fallback, in case there are other unexpected values
  ))
df_display %>% distinct(Cluster) %>% pull(Cluster)

```
## Building indexes

```{r}
#clusters_list <- split(df_display$col, df_display$Cluster)
# Initialize an empty dataframe to store the final results
final_df <- cities_clean %>% select(-c("geo_fips_code", "date_label"))

```

Scale between 0-1 with percent rank
```{r}
final_long = final_df %>% pivot_longer(!geo_label_city, names_to = "var", values_to = "value")
final_long = final_long %>% left_join(
  df_display %>% select(Cluster, col),
  by = join_by("var" == "col")
) 
final_idx = final_long %>% mutate(
  ptile = percent_rank(value),
  ptile = dplyr::case_when(ptile < (1 - max(ptile, na.rm = TRUE)) ~ (1 - max(ptile, na.rm = TRUE)), .default = ptile),
  .by = var
) %>% 
  summarise(
    idx_value = median(ptile, na.rm = TRUE),
    .by = c(Cluster, geo_label_city)
  ) %>% 
  pivot_wider(id_cols = geo_label_city, names_from = Cluster, values_from = idx_value)

```

```{r}
library(ggplot2)
df_cityclusters = df_clusters_joined %>% select(Cities, Cluster.x, Cluster.y)
complete = final_idx %>% left_join(df_cityclusters, by = join_by("geo_label_city" == "Cities"))
complete = complete %>% 
  mutate(total_score = ((-1 * health_poverty_index + -1 * safety_index + -1 * std_drug_index + income_eq_educ_index) / 5),
         bigcity_score = (bigcity_segregat_index - suburb_sprawl_index) / 2)
complete %>% select(geo_label_city, ends_with("index"), ends_with("score")) %>% pivot_longer(!geo_label_city) %>% 
  ggplot(aes(value, fill = name)) + geom_density(alpha = .6) +
  facet_grid(rows = vars(name), scales = "free")
```

```{r}
View(complete %>% select(geo_label_city, ends_with("score")))
```


```{r}
idx_names = colnames(complete)[endsWith(colnames(complete), "index")]
index_average = complete %>% group_by(Cluster.x) %>% summarise(across(.cols = idx_names, median, na.rm = TRUE ))
correlate(complete %>% select(ends_with("index")))
```

```{r}
happy_norepeats = happy %>% filter(!(City == "Columbus" & State == "Georgia")) %>% filter(!(City == "Portland" & State == "Maine"))
df_model_idx = complete %>% left_join(happy_norepeats, by = join_by( "geo_label_city"=="City"))
```



```{r}
correlate(df_model_idx$`Total Score`, df_model_idx$total_score)
```
```{r}
df_model_idx %>% select(total_score, geo_label_city) %>% arrange((total_score)) %>% head(5)
```
```{r}
df_model_idx <- df_model_idx %>%
  mutate(intRanking = rank(-total_score, ties.method = "first"),
         extRanking = rank(-`Total Score`, ties.method = "first")) %>%
  arrange(intRanking) %>% 
  mutate(diff = intRanking - extRanking)

mean(abs(df_model_idx$diff))
median(abs(df_model_idx$diff))
View(df_model_idx %>% select(geo_label_city, intRanking, extRanking, diff))
```
```{r}
df_model_idx_scaled = df_model_idx
df_model_idx_scaled$ext_score_scale = scale(df_model_idx$`Total Score`)
df_model_idx_scaled$int_score_scale = scale(df_model_idx$total_score)
```

```{r}
pop_change = read.csv("pop_change.csv")
#View(pop_change)
cities_list = cities_clean$geo_label_city

find_all_matching_cities <- function(metro_description, cities) {
  matched_cities <- cities[str_detect(metro_description, cities)]
  if (length(matched_cities) == 0) {
    return(NA)  # Return NA if no match is found
  }
  return(matched_cities)
}
pop_change$Metro.Area[str_detect(pop_change$Metro.Area, "New York")] = "New York City"
# Applying the function to each metro_area and creating a list column
pop_change$matched_cities <- map(pop_change$Metro.Area, find_all_matching_cities, cities = cities_list)

# Expanding the data frame so that each city gets its own row
data_expanded <- pop_change %>%
  unnest(matched_cities) %>%
  rename(major_city = matched_cities)

# Replace NA with a placeholder if you want
data_expanded$major_city[is.na(data_expanded$major_city)] <- "No Major City Matched"
data_expanded$major_city[str_detect(data_expanded$Metro.Area, "New York")] = "New York City"
## A number were false matches: Drop these
drop_indices = c(67, 83, 89, 118, 141, 145, 169)
data_expanded = data_expanded[-drop_indices, ]
data_pop = data_expanded %>% filter(major_city != "No Major City Matched") %>%  select(!Metro.Area)

data_pop
```
```{r}
data_pop =  data_pop %>%
  mutate(across(c(X2023, X2022, X2021, X2020), ~as.numeric(gsub(",", "", .))))
data_joined = data_pop %>% left_join(
  df_model_idx, by = join_by("major_city" == "geo_label_city")
)
data_joined %>% select(major_city, X2023, bigcity_score)
data_pop =  data_pop %>%
  mutate(across(c(X2023, X2022, X2021, X2020), ~as.numeric(gsub(",", "", .))))
correlate(data_joined$X2023, data_joined$bigcity_score)
```
```{r}
View(data_joined %>% select(major_city, X2023, bigcity_score))
```



## Response Variable: City ranking

This section of our model will be attempting to predict the happiness of a city, from this source https://wallethub.com/edu/happiest-places-to-live/32619, using the data from our dataframe

```{r}
# Assuming the data is tab-separated
happy <- read_csv("data/happiest_places_to_live.csv")
happy <- happy %>% filter(!is.na(City))
head(happy)
## Edit names to make them equal
happy <- happy %>%
  mutate(City = ifelse(City == "Detroit, MI", "Detroit", City)) %>% 
  mutate(City = ifelse(City == "Washington, DC", "Washington", City)) %>% 
  mutate(City = ifelse(City == "New York", "New York City", City))
```

```{r}
## Join 
joined = cities_clean %>% left_join(happy, by = join_by(geo_label_city == City))
response_cols = joined %>% select(any_of(colnames(happy)))
colnames(response_cols)
```