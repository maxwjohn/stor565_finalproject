---
title: "PCA"
author: "Nicolai"
date: "2024-03-29"
output: html_document
---

## Dimension Reduction: Method 1: PCA

```{r}
library(cluster)
library(factoextra)
```


```{r}
# replace transposed_data / city_var depending on if we want groupings for the variables or the cities
# Perform PCA
pca_result <- prcomp(numeric_data, scale. = TRUE)
summary(pca_result)
plot(pca_result$x[,1], pca_result$x[,2])
pca.var <- pca_result$sdev^2
# percantage of variation that each PCA accounts for
pca.var.per <- round(pca.var/sum(pca.var)*100, 1)
barplot(pca.var.per, main="Scree Plot", xlab="Principal Component", ylab="Percent Variation")
```
## PCA on this to check what 
```{r}
##### PCA continued
library(ggplot2)
## get the name of the top 10 measurements (cities) that contribute most to pc1.
loading_scores <- pca_result$rotation[,1]
var_scores <- abs(loading_scores) ## get the magnitudes
var_score_ranked <- sort(var_scores, decreasing=TRUE)
top_10_vars <- names(var_score_ranked[1:10])
 
top_10_vars ## show the names of the top 10 cities
 
pca_result$rotation[top_10_vars,1]
```

# Hierarchical clustering with PCA
```{r}
num_components <- 3  # number of principal components

# Extracting PCA scores for selected components
pca_scores <- pca_result$x[, 1:12]

# Performing hierarchical clustering
hc_result <- hclust(dist(pca_scores), method = "complete")

# Visualizing hierarchical clustering results
plot(hc_result, main = "Hierarchical Clustering Dendrogram")

# heatmap to visualize clustered samples
cluster_order <- cutree(hc_result, k = 3)  
heatmap(pca_scores[order(cluster_order), ], scale = "row", 
        Rowv = NA, Colv = NA, col = heat.colors(256),
        main = "Clustered Samples Heatmap")
```
```{r, fig.width=8, fig.height=10}
dend <- as.dendrogram(hc_result) # Visualizing dendrogram with actual column names
#labels(dend) <- rownames(numeric_data) # Adding names as labels
plot(dend, main = "Dendrogram for Hierarchical Clustering", horiz = TRUE)

########### Ordering clusters
# HC
num_clusters <- 3  # Adjustable
clusters <- cutree(hc_result, k = num_clusters)

# order of observations
order <- order.dendrogram(dend)

# DF with the labels and cluster assignments
cluster_labels <- data.frame( Cluster = clusters[order])
pca_clusters <- data.frame(pca_scores, Cluster = as.factor(clusters))
#pca_clusters %>% select(geo_label_city, Cluster)
#View(cluster_labels)
```

## Hierarchical clustering on columns
```{r}
scaled = scale(cities_clean %>% select(!c(geo_label_city, geo_fips_code, date_label)))
df_t <- t(scaled)

# Calculate the distance matrix using Euclidean distance (you can choose another method)
dist_matrix <- dist(df_t, method = "euclidean")

# Perform hierarchical clustering
hc_columns <- hclust(dist_matrix, method = "complete") # You can choose another linkage method

# Plot the dendrogram
plot(hc_columns, main = "Dendrogram of Columns", xlab = "Columns", sub = "", ylab = "Height")
```
#### Checking optimal clusters for variables
```{r}
sil_width <- vector("numeric", length = 14) # Adjust the length for the number of clusters to inspect minus one
for (k in 2:15) { # Starts from 2 because silhouette doesn't work with a single cluster
  cluster_assignments <- cutree(hc_columns, k)
  silhouette_analysis <- silhouette(cluster_assignments, dist_matrix)
  sil_width[k-1] <- mean(silhouette_analysis[, 3]) # Average silhouette width
}

# Plot the average silhouette width
plot(2:15, sil_width, type = "b", xlab = "Number of Clusters", ylab = "Average Silhouette Width", main = "Silhouette Method for Optimal Clusters")
```

```{r}
varclusters <- cutree(hc_columns, k = 6)

# If you want to see which columns are in each cluster

df_varclusters <- data.frame(df_t, Cluster = as.factor(varclusters)) %>% select(Cluster)
dend <- as.dendrogram(hc_columns) # Visualizing dendrogram with actual column names
#labels(dend) <- rownames(numeric_data) # Adding names as labels
plot(hc_columns, main = "Dendrogram of Columns", xlab = "Columns", sub = "", ylab = "Height")
```


There are a lot of variables, most seem to be fairly normal, although there does seem to be some categories that have similar distributions. Deaths, drug related variables, transporation variables, all seem to be pretty similar within its own group.

## Second Method: Dimension Reduction through feature selection by domain knowledge
```{r}
## 80 is too much to look at overall, but for some EDA going to look at first 10
cor(num_cols[,1:10]) # Very high correlation, need to see further how bad this problem is
library(corrr)
cor_matrix = cor(num_cols, use = "na.or.complete")
cor_matrix[,1]
cor_melted <- as.data.frame(as.table(cor_matrix))

# Filter to remove self-correlations and get only one of each pair
cor_melted_filtered <- subset(cor_melted, Var1 != Var2 & as.numeric(Var1) < as.numeric(Var2))

# Filter for high correlations
high_cor_pairs <- subset(cor_melted_filtered, abs(Freq) > 0.75)
print(high_cor_pairs)
```
There are 400 pairs of very high correlation (>.75). Sources of this are:
  - Death Variables
  - Children related variables
  - Transportation Variables
  - Single Parent Families
  - Income Inequality related variables
  - Poverty related variables

Specific variables that have a lot of high correlation are:
  - Preterm Births
  - Premature Death
  - Life Expectancy
  - Single-Parent Families
  - Household Income Inequality
  - Service Workers
  

With this level of correlation, using this to classify something, even like total score will not yield much meaningful results. However, we will try to classify cities into categories/groupings, and attempt to explain the variation when it does vary from each other, and apply these groupings in other situations.

In this part we will attempt to reduce our 86 variables to between 10-20 variables, and then try hierarchical clustering on these variables to attempt to get groupings. We will do this through a mix of checking correlations and domain understanding. THis will not be super mathematically driven, as we can look from the original histograms and these correlation matrices that there is no major difference between most of these variables, so we will pick variables that we think will give us the greatest amount of interpretability while still being able to keep some level of predictive power.

```{r}
colnames(cities_clean %>% select(!c("geo_label_city", "geo_fips_code", "date_label")))
```
A solid percentage of variables have to do with death/life expectancy. We are going to try to reduce these into a few variables, as many of these have very high correlations as well. These are a list of a bunch of variables that are all related to life expectancies and death.

```{r}
health_vars = c("COVID-19 Deaths","Deaths from All Causes", "Life Expectancy", "All Cancer Deaths", "Breast Cancer Deaths", "Lung Cancer Deaths", "Cardiovascular Disease Deaths", "Heart Disease Deaths", "High Blood Pressure",  "Diabetes", "Adult Obesity", "Adult Physical Inactivity", "Pneumonia or Influenza Deaths", "HIV-Related Deaths", "HIV/AIDS Prevalence", "New Chlamydia Cases", "Syphilis Prevalence", "Syphilis, Newborns", "New Gonorrhea Cases", "Maternal Deaths", "Infant Deaths", "Low Birthweight","Teen Births", "Opioid Overdose Deaths", "Adult Binge Drinking", "Drug Overdose Deaths", "Adult Smoking", "Injury Deaths", "Gun Deaths (Firearms)","Motor Vehicle Deaths",  "Police Killings", "Violent Crime", "Homicides", "Seniors", "Colorectal Cancer Deaths", "Prostate Cancer Deaths",         "Preterm Births","Premature Death"  )
```

```{r}
death_cor = corrr::correlate(cities_clean %>% select(contains("death")))
death_cor
```
*Premature Deaths* is a variable that can capture the pattern we are looking for, which is various stats that show taht people are unhealthier or dying earlier. This may allow us to reduce the features that we look through. Looking at the correlations for premature deaths, we can see very high correlation between the cancer variables and a bunch of other of the death variables. We are choosing to keep this, and will see what other death variables we will keep.

```{r}
prem_cor = death_cor[21]
hi_var_prem = death_cor$term[(prem_cor %>% pull("Premature Death")) > .75]
drop_vars = c()
drop_vars = append(drop_vars,hi_var_prem) # Drop NA values
## Checking other correlations with premature deaths
death_cor2 = corrr::correlate(cities_clean %>% select(c("Premature Death",  "Life Expectancy","High Blood Pressure",  "Diabetes", "Adult Obesity", "Adult Physical Inactivity", "HIV-Related Deaths", "HIV/AIDS Prevalence", "New Chlamydia Cases", "Syphilis Prevalence", "Syphilis, Newborns", "New Gonorrhea Cases", "Low Birthweight","Teen Births", "Adult Binge Drinking", "Adult Smoking", "Police Killings", "Violent Crime", "Homicides", "Seniors", "Preterm Births")))
prem_cor2 = death_cor2[2]
hi_var_prem2 = death_cor2$term[abs(prem_cor2 %>% pull("Premature Death")) > .75]
drop_vars = append(drop_vars, hi_var_prem2)
drop_vars = drop_vars[!sapply(drop_vars, is.na)]
leftover = health_vars %>% setdiff(drop_vars)
## Checking correlation of leftover variables
corrr::correlate(cities_clean %>% select(all_of(leftover)))
## Other High Correlations: STD variables, Drug overdose
## Solving STD correlation problems: Combining into one variable
std_vars = c("HIV-Related Deaths", "HIV/AIDS Prevalence","New Chlamydia Cases", "Syphilis Prevalence", "Syphilis, Newborns","New Gonorrhea Cases")
std_df <- cities_clean %>%
  mutate(across(all_of(std_vars), 
                ~(. - mean(., na.rm = TRUE)) / sd(., na.rm = TRUE), 
                .names = "{.col}_standardized")) %>% 
  rowwise() %>%
  mutate(average_std = mean(c_across(ends_with("_standardized")), na.rm = TRUE)) %>%
  ungroup()
new_df = cities_clean
new_df$average_std = std_df$average_std
drop_vars = append(drop_vars, std_vars)
```
With some of the variables, there was obvious choices to be made, such as there was a .98 correlation between *Drug Overdose Deaths* and *Opioid Overdose Deaths*. We chose the drug variable as it was a little broader. However, with the std variables, there was no obvious variable that would be able to reflect the rest, so we combined them together into one variable that was an average of all of them. 

At this moment, *Premature Deaths* remains our choice of how to reflect the health/death related variales, as it is a good reflection based on an understanding of premature deaths as a concept. If a lot of people are dying earlier than expected it is likely an area with poor health, and potentially also dangerous. Although we may be losing a level of predictive power, it is necessary for us to be able to reduce the dimensionality of our problem.


Next, we will look at smaller relationships, starting with Homelessness, Transportation and segregation

```{r}
correlate(new_df %>% select(contains("Homelessness"))) # these can be kept the way they are
correlate(new_df %>% select(contains("Segregation"))) # Will focus primarily on White and Non-White, others wont be quite as important
correlate(new_df %>% select(contains("Poverty"))) ## Going to keep Poverty in all Ages
drop_vars = append(drop_vars, c("Opioid Overdose Deaths", "Racial Segregation, White and Black", "Racial Segregation, White and Asian", "Racial Segregation, White and Hispanic", "Poverty and Near Poverty in All Ages", "Poverty in Children"))
new_df = new_df %>% select(!any_of(drop_vars))
```

In this code chunk, we dropped the other segregation variables and are focusing on white and non-white, and kept the broader of the poverty variables: *Poverty in All Ages*.

We will be testing how many high correlation pairs we have left to see how many more variables we need to drop.

## Checking how much correlation we have left
```{r}
cor_matrix = cor(new_df %>% select(!c("geo_label_city", "geo_fips_code", "date_label")), use = "na.or.complete")
cor_matrix[,1]
cor_melted <- as.data.frame(as.table(cor_matrix))

# Filter to remove self-correlations and get only one of each pair
cor_melted_filtered <- subset(cor_melted, Var1 != Var2 & as.numeric(Var1) < as.numeric(Var2))

# Filter for high correlations
high_cor_pairs <- subset(cor_melted_filtered, abs(Freq) > 0.75)
print(high_cor_pairs)
high_cor_pairs %>% group_by(Var1) %>% count() %>% arrange(desc(n))
high_cor_pairs %>% group_by(Var2) %>% count() %>% arrange(desc(n))
```
Variables with high correlations with other variables are as we printed out. We wish to capture some factor about economy, some factor of health, some factor about housing, something with education, and something with transportation. 

From here we are going to drop variables that have high correlations and do not seem to be helpful. To begin, *Lack of Car* has high correlations with 2 variables, and lack of car seems like it could be explained easily by other variables such as income and city, and this can be covered by the walking to work variable. The *Service Workers* variable is another variable that has high correlations, and this variation could be covered by other variables such as income, and does not seem to be too important to predict city type. The income related variables all seem to have a lot of correlated relationships. *Household Income Inequality* is highly correlated with many other variables, and so we will drop all the variables that it has high correlation with to see if we can explan the variation related with other employment and income related variables.

*Population Density* is a variable that is highly correlated with many variables, and when it comes to quality of a city, density is not the only factor, and the related factors could be more powerful and capture this variation such as transportation and supermarket access among others.

Smaller Pairs that have high variation: 
- Uninsured, All Ages	vs. Uninsured, Child (keep *Uninsured, All Ages	*)
- Owner Occupied Housing vs. 	Renters vs. Owners (keep *Owner Occupied Housing*)
- Income Variables: keeping *Per-capita Household Income*
- *Drives Alone to Work*: Other important variables similar to this

```{r}
## Employee/Income variables
emp_inc_vars = c("Poverty in All Ages", "Per-capita Household Income", "Households with Higher-Incomes", "Service Workers", "Unemployment")
## Transportation Variables
transp_vars = c("Drives Alone to Work", "Population Density", "Riding Bike to Work", "Longer Driving Commute Time", "Walking to Work", "Lack of Car", "Public Transportation Use")
correlate(new_df %>% select(any_of(emp_inc_vars)))
correlate(new_df %>% select(any_of(transp_vars)))
more_vars = setdiff(emp_inc_vars, "Poverty in All Ages") %>%
  union(
  setdiff(transp_vars, "Public Transportation Use")
)
new_df = new_df %>% select(!any_of(more_vars)) %>% select(!`Uninsured, Child`)
```
Looking through transportation related variables and employment/income variables, we are going to keep *Public Transportation Use* and *Poverty in all Ages*, because these were both highly correlated with the other variables within their category, and are very explainable for reasons, as poverty and public transportation seem to be very important for a city and its quality of living.


```{r}
cor_matrix = cor(new_df %>% select(!c("geo_label_city", "geo_fips_code", "date_label")), use = "na.or.complete")
cor_matrix[,1]
cor_melted <- as.data.frame(as.table(cor_matrix))

# Filter to remove self-correlations and get only one of each pair
cor_melted_filtered <- subset(cor_melted, Var1 != Var2 & as.numeric(Var1) < as.numeric(Var2))

# Filter for high correlations
high_cor_pairs <- subset(cor_melted_filtered, abs(Freq) > 0.75)
print(high_cor_pairs)
high_cor_pairs %>% group_by(Var1) %>% count() %>% arrange(desc(n))
high_cor_pairs %>% group_by(Var2) %>% count() %>% arrange(desc(n))
```
Last variables droppped:

We have left a lot of important variables that all seem to potentially important. We need to drop a few of these variables, so there is no perfect solution. These are what we finally dropped:
- *People with Disabilities*: Seems like it could be represented by a number of other variables
- *Vacant Housing Units*: Does not seem as important, high correlation with other variables
- *Household Income Inequality*: very high correlation with poverty, also has high correlation with other variables
- *Single-Parent Families*: This would also seem to be highly correlated with poverty
- *Preschool Enrollment*: High correlation with college graduates which we like better
- *Owner Occupied Housing*: Almost 1 correlation with *Renters vs. Owners*, which we are keeping
- *Children*: Does not seem to predictive, there are better variables than this
- *Primarily Speak Spanish*, *Primarily Speak English*: *Foreign Born Population* is highly correlated and seems like it could be more important
- *Public Assistance*: This is highly correlated with poverty but we will be keeping the poverty variable
- *Dental Care*: Has high correlations but does not seem to be as predictive as many of the other variables in this for livability
- *New Tuberculosis Cases*: Not predictive
- *Adult Physical Inactivity*: high correlation with others and not as predictive


```{r}
final_drop = c(
  "People with Disabilities", "Vacant Housing Units", 
  "Household Income Inequality", "Single-Parent Families",
  "Preschool Enrollment", "Owner Occupied Housing", "Children",
  "Primarily Speak Spanish", "Dental Care", "Primarily Speak English", "Public Assistance", "New Tuberculosis Cases", "Adult Physical Inactivity"
)
new_df = new_df %>% select(!any_of(final_drop))
```
## Final Correlations
```{r}
cor_matrix = cor(new_df %>% select(!c("geo_label_city", "geo_fips_code", "date_label")), use = "na.or.complete")
cor_matrix[,1]
cor_melted <- as.data.frame(as.table(cor_matrix))

# Filter to remove self-correlations and get only one of each pair
cor_melted_filtered <- subset(cor_melted, Var1 != Var2 & as.numeric(Var1) < as.numeric(Var2))

# Filter for high correlations
high_cor_pairs <- subset(cor_melted_filtered, abs(Freq) > 0.75)
print(high_cor_pairs)
high_cor_pairs %>% group_by(Var1) %>% count() %>% arrange(desc(n))
high_cor_pairs %>% group_by(Var2) %>% count() %>% arrange(desc(n))
```
We are okay with a little bit of correlation, as long as it is not the majority of the dataset. We went from 400 pairs to only 6, and none of them are over .85, and if this is is still a problem we can reduce further. These are our variables with low correlations before some final domain understanding to further reduce to only important variables.

- Prostate, Diabetes, Flu/Pneumonia deaths: Not a huge portion of deaths are in this way, does not seem too important
- Homelessness and Vacant Housing: broad, covered by other homeless variabels

```{r}
colnames(new_df)
unimp_vars = c("Prostate Cancer Deaths", "Poor Air Quality","Primarily Speak Chinese",  "Prostate Cancer Deaths", "Diabetes Deaths", "Pneumonia or Influenza Deaths", "Homelessness and Vacant Housing" )
new_df = new_df %>% select(!all_of(unimp_vars))
```

## Final Variables for clustering
```{r}
colnames(new_df)
```

## base df on cities
```{r}
scaled_red = scale(new_df %>% select(!c(geo_label_city, geo_fips_code, date_label)))
hc_red = hclust(dist(scaled_red))
#hc = cutree(a, k = 5)
cluster_redassignments <- cutree(hc_red, k = 3)

# Create a dataframe with cluster assignments
df_redclusters <- data.frame(new_df, Cluster = as.factor(cluster_redassignments))
df_redclusters %>% select(geo_label_city, Cluster)
```

```{r}
plot(hc_red, labels = FALSE) # Set labels=FALSE to avoid cluttering
rect.hclust(hc_red, k = 3, border = "red") # Add rectangles to delineate the 4 clusters

rownames(new_df) = substr(new_df$geo_label_city, 1, 5)
# Add text labels
# Compute appropriate y positions for text labels (may need adjustment)
y_positions <- rep(min(hc_red$height), length(cluster_assignments))
text(x = 1:length(cluster_assignments), y = y_positions, labels = row.names(new_df), cex = 0.6, pos = 3)
```


## Hierarchical clustering on columns
```{r}
df_tred <- t(scaled_red)

# Calculate the distance matrix using Euclidean distance (you can choose another method)
dist_red_matrix <- dist(df_tred, method = "euclidean")

# Perform hierarchical clustering
hc_redcolumns <- hclust(dist_red_matrix, method = "complete") # You can choose another linkage method

# Plot the dendrogram
plot(hc_redcolumns, main = "Dendrogram of Columns", xlab = "Columns", sub = "", ylab = "Height")

varclusters_red <- cutree(hc_redcolumns, k = 5)

# If you want to see which columns are in each cluster

df_redvarclusters <- data.frame(df_tred, Cluster = as.factor(varclusters_red)) %>% select(Cluster)
```
## Final Variable Clusters:
Comparison between:
1) Clusters on Cities
```{r}
pca_clusters$Cities = rownames(pca_clusters)
df_clusters_joined = pca_clusters %>% left_join(
  df_redclusters %>% select(geo_label_city, Cluster), by = join_by("Cities" == "geo_label_city")
)
df_clusters_joined %>% select(Cities, starts_with("Clust"))

```
With dimension reduction and PCA, the cluster categories were exactly the same. This is good for us keeping what we wanted.


```{r}
#library(dplyr)
library(igraph)
library(networkD3)
#View(df_varclusters)
#View(df_redvarclusters)
df_sank = df_clusters_joined %>% select(Cluster.x, Cluster.y, Cities)
#write.csv(df_sank, "test.csv")
plot_sankey(df_sank, from_to= c("Cities", "Cluster.x", "Cluster.y"))
```
Variable clusters vary greatly between the two.

